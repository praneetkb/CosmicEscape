<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Turret.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cosmic Escape</a> &gt; <a href="index.source.html" class="el_package">ca.sfu.cmpt276.fall2025.team14.model</a> &gt; <span class="el_source">Turret.java</span></div><h1>Turret.java</h1><pre class="source lang-java linenums">package ca.sfu.cmpt276.fall2025.team14.model;

import ca.sfu.cmpt276.fall2025.team14.utils.VisionAttacher;
import de.gurkenlabs.litiengine.Direction;
import de.gurkenlabs.litiengine.Game;
import de.gurkenlabs.litiengine.Valign;
import de.gurkenlabs.litiengine.entities.CollisionInfo;
import de.gurkenlabs.litiengine.entities.EntityInfo;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import static de.gurkenlabs.litiengine.Align.CENTER;

import ca.sfu.cmpt276.fall2025.team14.app.GameLogic;
import de.gurkenlabs.litiengine.Game;

/**
 * The {@code Turret} class represents a stationary enemy in the game that can rotate
 * within a limited angle range and detect players using its {@link Vision} component.
 * &lt;p&gt;
 * This class extends Creature and implements IUpdateable, allowing
 * it to perform continuous updates at every tick of the game.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The turret can rotate back and forth between a minimum and maximum angle.
 * If the player is caught, a collision with the {@link Player} occurs and the game restarts via {@link GameLogic#restartLevel()}.
 * &lt;/p&gt;
 *
 */

@EntityInfo(width = 16, height = 16)
@CollisionInfo(collisionBoxWidth = 12, collisionBoxHeight =12, collision = true, align = CENTER, valign = Valign.MIDDLE)
public class Turret extends Enemy {

    /**
     * The vision area attached to the turret.
     */
    private final Vision vision;
    // Rotation config (UP-based degrees)
    private static final double DEFAULT_DEG_PER_SEC = 30;
<span class="fc" id="L42">    private double degPerSec = DEFAULT_DEG_PER_SEC;</span>
<span class="fc" id="L43">    private double minRotation = 1;</span>
<span class="fc" id="L44">    private double maxRotation = 360;</span>
<span class="fc" id="L45">    private boolean clockwise = true;</span>
<span class="fc" id="L46">    private Direction lastDir = Direction.UP;</span>
<span class="fc" id="L47">    private double hysteresisDeg = 12.0;</span>

    // Runtime state
<span class="fc" id="L50">    private double currentDegree = minRotation;</span>

    // LOS rays
    private static final double EDGE_OFFSET_DEG = 14.0;
    private static final double LOS_LEN = 10.0 + 32.0;
<span class="fc" id="L55">    private final Line2D.Double losCenter = new Line2D.Double();</span>
<span class="fc" id="L56">    private final Line2D.Double losLeft = new Line2D.Double();</span>
<span class="fc" id="L57">    private final Line2D.Double losRight = new Line2D.Double();</span>

    /**
     * Constructs a new {@code Turret} and attaches a vision to it.
     */
    public Turret() {
<span class="fc" id="L63">        super(&quot;turret&quot;);</span>
        // Attach vision
<span class="fc" id="L65">        vision = new Vision();</span>
<span class="fc" id="L66">        VisionAttacher.attach(this, vision);</span>
<span class="fc" id="L67">    }</span>

    @Override
    public void update() {
        // Frame-rate independent sweep on a linear axis
<span class="fc" id="L72">        final double dt = Game.loop().getDeltaTime() / 1000.0;</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        double step = degPerSec * dt * (clockwise ? +1.0 : -1.0);</span>
<span class="fc" id="L74">        double next = currentDegree + step;</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (next &gt; maxRotation) {</span>
<span class="nc" id="L76">            double o = next - maxRotation;</span>
<span class="nc" id="L77">            next = maxRotation - o;</span>
<span class="nc" id="L78">            clockwise = false;</span>
        }
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (next &lt; minRotation) {</span>
<span class="fc" id="L81">            double o = minRotation - next;</span>
<span class="fc" id="L82">            next = minRotation + o;</span>
<span class="fc" id="L83">            clockwise = true;</span>
        }
<span class="fc" id="L85">        currentDegree = next;</span>
        // Sync vision sprite to current rotation
<span class="fc" id="L87">        VisionAttacher.syncTurretVision(this, vision, currentDegree);</span>
        // Calculate base degree rotation for rays
<span class="fc" id="L89">        final Point2D c = this.getCenter();</span>
<span class="fc" id="L90">        final double theta = Math.toRadians(currentDegree - 90.0);</span>
<span class="fc" id="L91">        final double ux = Math.cos(theta), uy = Math.sin(theta);</span>
<span class="fc" id="L92">        final double off = Math.toRadians(EDGE_OFFSET_DEG);</span>
        // center ray
<span class="fc" id="L94">        final double sx = c.getX(), sy = c.getY();</span>
<span class="fc" id="L95">        double ex = sx + ux * LOS_LEN, ey = sy + uy * LOS_LEN;</span>
<span class="fc" id="L96">        losCenter.setLine(sx, sy, ex, ey);</span>
        // left edge (+14°)
<span class="fc" id="L98">        double uxL = Math.cos(theta + off), uyL = Math.sin(theta + off);</span>
<span class="fc" id="L99">        double exL = sx + uxL * LOS_LEN, eyL = sy + uyL * LOS_LEN;</span>
<span class="fc" id="L100">        losLeft.setLine(sx, sy, exL, eyL);</span>
        // right edge (-14°)
<span class="fc" id="L102">        double uxR = Math.cos(theta - off), uyR = Math.sin(theta - off);</span>
<span class="fc" id="L103">        double exR = sx + uxR * LOS_LEN, eyR = sy + uyR * LOS_LEN;</span>
<span class="fc" id="L104">        losRight.setLine(sx, sy, exR, eyR);</span>
        // Set sprite rotation based on degree
<span class="fc" id="L106">        setDirection();</span>
<span class="fc" id="L107">    }</span>

    private void setDirection() {
        // Normalize degrees
<span class="fc" id="L111">        double deg = currentDegree;</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        while (deg &lt; 0) deg += 360.0;</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        while (deg &gt;= 360.0) deg -= 360.0;</span>
        // Quadrants
<span class="fc" id="L115">        final double h = hysteresisDeg;</span>
<span class="fc" id="L116">        final double U_R = 45.0, R_D = 135.0, D_L = 225.0, L_U = 315.0;</span>
        // Get direction
<span class="fc" id="L118">        Direction next = lastDir;</span>
<span class="fc bfc" id="L119" title="All 4 branches covered.">        final boolean inRIGHT = (deg &gt;= U_R + h &amp;&amp; deg &lt; R_D - h);</span>
<span class="pc bpc" id="L120" title="1 of 4 branches missed.">        final boolean inDOWN = (deg &gt;= R_D + h &amp;&amp; deg &lt; D_L - h);</span>
<span class="pc bpc" id="L121" title="3 of 4 branches missed.">        final boolean inLEFT = (deg &gt;= D_L + h &amp;&amp; deg &lt; L_U - h);</span>
<span class="pc bpc" id="L122" title="1 of 4 branches missed.">        final boolean inUP = (deg &gt;= L_U + h || deg &lt;= U_R - h);</span>
<span class="pc bpc" id="L123" title="4 of 5 branches missed.">        switch (lastDir) {</span>
<span class="pc bpc" id="L124" title="1 of 4 branches missed.">            case UP -&gt; next = inRIGHT ? Direction.RIGHT : inLEFT ? Direction.LEFT : Direction.UP;</span>
<span class="nc bnc" id="L125" title="All 4 branches missed.">            case RIGHT -&gt; next = inDOWN ? Direction.DOWN : inUP ? Direction.UP : Direction.RIGHT;</span>
<span class="nc bnc" id="L126" title="All 4 branches missed.">            case DOWN -&gt; next = inLEFT ? Direction.LEFT : inRIGHT ? Direction.RIGHT : Direction.DOWN;</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">            case LEFT -&gt; next = inUP ? Direction.UP : inDOWN ? Direction.DOWN : Direction.LEFT;</span>
        }
        // Set direction
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (next != lastDir) {</span>
<span class="fc" id="L131">            setFacingDirection(next);</span>
<span class="fc" id="L132">            lastDir = next;</span>
        }
<span class="fc" id="L134">    }</span>

    @Override
    public boolean playerInLos() {
<span class="fc" id="L138">        Rectangle2D playerCB = Player.instance().getCollisionBox();</span>
<span class="pc bpc" id="L139" title="2 of 6 branches missed.">        return losCenter.intersects(playerCB) || losLeft.intersects(playerCB) || losRight.intersects(playerCB);</span>
    }

    public static double getDefaultDegPerSec() {
<span class="fc" id="L143">        return DEFAULT_DEG_PER_SEC;</span>
    }

    public Vision getVision() {
<span class="fc" id="L147">        return vision;</span>
    }

    public Line2D.Double getLosCenter() {
<span class="fc" id="L151">        return losCenter;</span>
    }

    public double getDegPerSec() {
<span class="nc" id="L155">        return degPerSec;</span>
    }

    public void setDegPerSec(double degPerSec) {
<span class="fc" id="L159">        this.degPerSec = degPerSec;</span>
<span class="fc" id="L160">    }</span>

    public double getMinRotation() {
<span class="nc" id="L163">        return minRotation;</span>
    }

    public void setMinRotation(double minRotation) {
<span class="fc" id="L167">        this.minRotation = minRotation;</span>
<span class="fc" id="L168">    }</span>

    public double getMaxRotation() {
<span class="nc" id="L171">        return maxRotation;</span>
    }

    public void setMaxRotation(double maxRotation) {
<span class="fc" id="L175">        this.maxRotation = maxRotation;</span>
<span class="fc" id="L176">    }</span>

    public double getCurrentDegree() {
<span class="nc" id="L179">        return currentDegree;</span>
    }

    public void setCurrentDegree(double currentDegree) {
<span class="fc" id="L183">        this.currentDegree = currentDegree;</span>
<span class="fc" id="L184">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>